{
  "name": "types.js",
  "version": "1.3.9",
  "description": "A tiny (1.8kb), but essential Javascript type-check library",
  "main": "types.min.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/phazelift/types.js"
  },
  "keywords": [
    "type",
    "typeof",
    "types",
    "validation",
    "check",
    "type-checking",
    "force",
    "force-type",
    "is",
    "not",
    "has",
    "all"
  ],
  "author": {
    "name": "Dennis Raymondo",
    "email": "phazelift@gmail.com",
    "url": "https://github.com/phazelift/"
  },
  "license": "GPL-3",
  "bugs": {
    "url": "https://github.com/phazelift/types.js/issues"
  },
  "homepage": "https://github.com/phazelift/types.js",
  "dependencies": {},
  "devDependencies": {},
  "readme": "types.js\n========\n<br/>\nA tiny (1.8kb), but essential Javascript type checking library.\n\nEspecially in non-typed scripting languages like Javascript, proper manual type checking is crucial.\nBecause type checking in Javascript is such a mess, I decided to make a library with clear standards\nI can build upon.\n\n**A few quick examples with types.js:**\n```javascript\n_.typeof( [] );\t\t\t\t\t\t\t// 'array'\n_.typeof( null );\t\t\t\t\t\t// 'null'\n_.typeof( /someregexp/ );\t\t\t\t// 'regexp'\n_.typeof( parseInt('Not A Number!') );\t// 'nan'\n_.forceString( 123 );\t\t\t\t\t// '123'\n_.allDefined( 'good', false, null );\t// true (null !== undefined in strict mode)\n_.hasObject( 'not', 'really' );\t\t\t// false\n// there is much more! see below.\n```\nForce!\n------\nForce some value to be of some type. A replacement value can be given in case value is invalid, without replacement\na default literal of the forced type will be returned.\n```javascript\nvar left= '500px';\nvar callback= null;\n// now some 10 lines of code to be save:\nif ( typeof left === 'string' ){\n\t\tleft= parseInt( left, 10 );\n}\n// check if parseInt returned NaN..\nif ( left !== left || typeof left !== 'number' )\n\tleft= 100;\n}\nif ( typeof callback !== 'function' ){\n\tcallback= function(){}\n}\ncallback( left );\n// 2 lines of code with force, and a better read if you ask me:\nleft=  _.forceNumber( left, 100 );\n_.forceFunction( callback )( left );\n// see below for more examples\n```\nCheck it out, it's sweet! I've added force to types.js because I use it all the time and it seems to belong in here.\n___\nFor use with node.js you can install with `npm install types.js`\n___\n\nBasic usage:\n------------\n\n**force'Type'** Forces a value to be of a given type, and returns that value, a replacement, or it's literal default.\n\n**is'Type'** and **not'Type'** are useful for single argument type checking.\n\n**all'Type'** is useful for checking if all given arguments are of a certain type.\n\n**has'Type'** is useful for checking if one or more arguments are of a certain type.\n\n**typeof** Returns a lowercase string representation of the type of the argument value, according to types.js type-definitions.\n___\n\n**some more examples:**\n```javascript\nvar _= Types;\t\t\t\t\t\t\t\t\t// browser\nvar _= require( 'types.js' );\t\t\t\t\t// in node.js with npm\n\nvar x;\n// initialize a variable and be sure what type it will have in any case:\nx= _.forceString();\t\t\t\t\t\t\t\t// '' (empty String)\nx= _.forceString( null, 'ok' );\t\t\t\t\t// 'ok' (as String)\nx= _.forceString( null, [1, 2, 3] );\t\t\t// '' (empty String)\nx= _.forceString(33);\t\t\t\t\t\t\t// '33' (as String)\nx= _.forceNumber('35px');\t\t\t\t\t\t// 35 (as Number)\nx= _.forceNumber( true, function(){} );\t\t\t// 0 (as Number)\nx= _.forceBoolean('35px');\t\t\t\t\t\t// false (as Boolean)\nx= _.forceArray(\"you'll get an array\");\t\t\t// []\n\nvar func= null;\n// call a function that might not exist anymore:\n_.forceFunction( func )( 'arguments for func, or replacement' );\n// no crash, default empty function is called, returns undefined\n\n// some default type checking:\nx= _.isDefined()\t\t\t\t\t\t\t\t// false\nx= _.isString( 'Hello types.js!' );\t\t\t\t// true\nx= _.isString( 23456 );\t\t\t\t\t\t\t// false\nx= _.isBoolean( false );\t\t\t\t\t\t// true\nx= _.isArray( [1,2,3] );\t\t\t\t\t\t// true\nx= _.isObject( [1,2,3] );\t\t\t\t\t\t// false\nx= _.isObject( /myRegExp/g );\t\t\t\t\t// false\nx= _.isNaN( parseInt('generate NaN') );\t\t\t// true\n\nx= _.notNull('');\t\t\t\t\t\t\t\t// true\nx= _.notUndefined( undefined );\t\t\t\t\t// false\nx= _.isDefined( null );\t\t\t\t\t\t\t// true\n\n// check multiple values in one call:\nx= _.allString( '', \" \", 'with text' );\t\t\t\t\t\t// true\nx= _.allString( '', ' ', 'with text', 123 );\t\t\t\t// false\nx= _.allStringOrNumber( '', ' ', 'with text', 123 );\t\t// true\nx= _.allObject( { key: 'nice' }, [], /regexp/ig );\t\t\t// false\nx= _.allArray( [1,2,3], [{}], new RegExp('stop') );\t\t\t// false\nx= _.allArray( [1,2,3], [{}], [false, true] );\t\t\t\t// true\n\nx= _.hasString( 123, { value: 'nice' }, ['?'] );\t\t\t// false\nx= _.hasStringOrNumber( [1,2], /reg/, 'true' )\t\t\t\t// true\nx= _.hasFunction( 123, { value: 'nice' }, function(){} );\t// true\nx= _.hasUndefined( 'render false!', 123, null );\t\t\t// false\nx= _.hasUndefined( 'render true!', 123, undefined );\t\t// true\n\n// check for a types.js type definition, returns lowercase string:\nx= _.typeof( [1,2,3] );\t\t\t\t\t\t\t\t\t\t// 'array'\nx= _.typeof( null );\t\t\t\t\t\t\t\t\t\t// 'null'\nx= _.typeof( parseInt('generate NaN') );\t\t\t\t\t// 'nan'\nx= _.typeof( new Date() );\t\t\t\t\t\t\t\t\t// 'date'\n// etc..\n```\n___\nAPI\n---\n\n**Types.parseIntBase**\n> `<Number> parseIntBase= 10`\n\nHolds the Radix used by forceNumber, defaults to decimals. Can be set to valid radixes for parseInt(). Note that once set, all\nfollowing forceNumber calls will use the new Radix.\n```javascript\n_.parseIntBase= 0xf;\n// parse from hexadecimal\nvar nr= _.forceNumber( 'a linefeed' );\nconsole.log( nr );\n// 10 (decimal)\n```\n**Types.forceBoolean**\n> `<String> Types.forceBoolean( value, replacement )`\n\nReturns value if value is of type Boolean. Otherwise it will try to convert value to be a Boolean. If that\nfails too, replacement will be tested for, or converted to, 'boolean' if possible. If that fails, the default\ntypes.js boolean literal is returned: a Boolean `false`\n```javascript\nvar assert= _.forceBoolean( 'Only a true true returns true' );\nconsole.log( assert );\nvar assert= _.forceBoolean( NaN != NaN );\nconsole.log( assert );\n// true\n```\n**Types.forceString**, **Types.forceArray**, **Types.forceObject**\n\nJust like forceBoolean, only applying the type denoted by the method name. See the force'Type' literals for\nthe different methods below.\n\n**Types.forceNumber**\n > `<Number> forceNumber( <String>/<Number> value, <String>/<Number> replacement )`\n\nReturns value if it is a Number or convertable to a Number. Returns replacement if value is invalid or not convertable.\nReturns a Number object with a .void property set to true if no valid value and replacement were given or no conversion was possible.\n\nYou can check yourNumber.void to see if yourNumber is set to a valid number. If .void is true, yourNumber is not set to a\nnumber, but to a Number object which is ready for mathemetical operation, and defaults to 0.\n\n`Types.typeof( Types.forceNumber() );` returns 'number', as it is a Number and you can use it as number.\n\nExample: make a numberFilter for arguments with the new forceNumber:\n```javascript\nfunction numberFilter(){\n\tvar numbers= [];\n\tfor( var arg in arguments ){\n\t\tvar value= _.forceNumber( arguments[arg] );\n\t\tif( value.void )\n\t\t\tcontinue;\n\t\tnumbers.push( value );\n\t}\n\treturn numbers;\n}\n\nfunction someFunc(){\n\treturn numberFilter.apply( this, arguments );\n}\nconsole.log( someFunc('ignore', 1, 'the', 2, 'strings!', 3) );\n// [ 1, 2, 3 ]\nconsole.log( someFunc('1 but', '2 not', '3 unconditional!') );\n// [ 1, 2, 3 ]\n```\n\n**Types.forceFunction**\n> `<Function> Types.forceFunction( <Function> func, <Function> replacement )`\n\nReturns func if it is a Function. So you can call your function with Types.forceFunction(func)( args ). If it is\na Function, it will call and pass the given arguments.\n\nforceFunction will not try/catch func for other failures.\n\nIf func or replacement are not of type Function, a dummy function will be called returning undefined.\n```javascript\nvar showAuthor= function( name ){\n\tconsole.log( 'Author: '+ _.forceString(name) );\n};\n\n_.forceFunction( showAuthor )( 'Dennis Raymondo' );\n// Author: Dennis Raymondo\n\nvar showAuthor= null;\n// now call with an anonymus replacement function as showAuthor will fail:\n_.forceFunction( showAuthor, function(name){\n\tconsole.log( 'Could not call showAuthor! Arguments: '+ _.forceString(name) );\n})( 'Dennis Raymondo' );\n// Could not call showAuthor! Arguments: Dennis Raymondo\n```\n**Types.typeof**\n> `<String> Types.typeof( value )`\n\nReturns a lowercase string representation of the type of value, according to types.js types. See all types.js\ntype-definitions below.\n```javascript\nvar nan= parseInt( 'damn NaN!' );\nconsole.log( _.typeof(nan) );\n// 'nan'\n```\n**Types.isBoolean**\n> `<Boolean> Types.isBoolean( value )`\n\nReturns true if the given argument is a Boolean true or false\n```javascript\nconsole.log( _.isBoolean(false) );\n// true\n```\n**Types.notBoolean**\n> `<Boolean> Types.isBoolean( value )`\n\nReturns true if the given argument is not a Boolean true or false\n```javascript\nconsole.log( _.notBoolean('not a Boolean') );\n// true\n```\n**Types.hasBoolean**\n> `<Boolean> Types.hasBoolean( values, [value1, ..., valueN])`\n\nReturns true if any of the given arguments is a Boolean true or false\n```javascript\nconsole.log( _.hasBoolean('the third', null, false) );\n// true\n```\n**Types.allBoolean**\n> `<Boolean> Types.allBoolean( values, [value1, ..., valueN])`\n\nReturns true only if all given arguments are either a Boolean true or false\n```javascript\nconsole.log( _.allBoolean(false, null, true) );\n// false\n```\nAll remaining methods are equal to the last four above, except for that they differ in the type being checked. The complete\nlist of all these methods:\n\nnot\t\t\t\t\t|is\t\t\t\t\t|has\t\t\t\t\t|all\n:-----------------|:----------------|:----------------|:-----------------\nnotBoolean\t\t\t|isBoolean\t\t\t|hasBoolean\t\t\t|allBoolean\nnotString\t\t\t|isString\t\t\t|hasString\t\t\t|allString\nnotNumber\t\t\t|isNumber\t\t\t|hasNumber\t\t\t|allNumber\nnotStringOrNumber\t|isStringOrNumber\t|hasStringOrNumber|allStringOrNumber\nnotObject\t\t\t|isObject\t\t\t|hasObject\t\t\t|allObject\nnotArray\t\t\t\t|isArray\t\t\t\t|hasArray\t\t\t|allArray\nnotFunction\t\t\t|isFunction\t\t\t|hasFunction\t\t|allFunction\nnotRegexp\t\t\t|isRegexp\t\t\t|hasRegexp\t\t\t|allRegexp\nnotDate\t\t\t\t|isDate\t\t\t\t|hasDate\t\t\t\t|allDate\nnotNull\t\t\t\t|isNull\t\t\t\t|hasNull\t\t\t\t|allNull\nnotUndefined\t\t|isUndefined\t\t|hasUndefined\t\t|allUndefined\nnotDefined\t\t\t|isDefined\t\t\t|hasDefined\t\t\t|allDefined\nnotNaN\t\t\t\t|isNaN\t\t\t\t|hasNaN\t\t\t\t|allNaN\n\n____________________________\n**types.js type definitions:**\n\n'boolean', 'string', 'number', 'object', 'array', 'function', 'regexp', 'date', 'null', 'undefined', 'nan'\n\n____________________________\n**force'Type' method and default literals**\n> `<'Type'> force'Type'( <any type> value, <'Type'> replacement )`\n\nThe literals returned by default:\n\nforceBoolean\t|forceString\t|forceNumber\t|forceObject\t\t|forceArray\t\t|forceFunction\n---------------|--------------|--------------|--------------|--------------|--------------\n`false`\t\t\t|`''`\t\t\t\t|`0` (Number)\t|`{}`\t\t\t\t|`[]`\t\t\t\t|`function(){}`\n\nchange log\n==========\n\n1.3.9\n\nRemoved 'unknown' from types.js type definitions. It was meant to be like a final state, for if no other matching type could\nbe found, but in the codebase as it is now, that state can never be reached.. If Javascript ever invents a brand new type,\ntypes.js will return 'defined' on that one if I would not take action and implement support for it.\n\nUpdated the readme.\n\n__________________________________________\n1.3.5\n\nChanged:\n-\tforceNumber doesn't return 0 by default anymore. It now returns a Number object with a .void property which is set to\n\ttrue if no valid Number was given or no conversion was possible.\n\n\tJust use: `_.forceNumber( value, 0 );` to return a 0 as replacement, it only is not default anymore.\n\n\tI made this change because I wanted to be able to check if forceNumber was successful. Just a 0 can be very misleading and\n\ta source for bugs. NaN is a failure IMO, so I made a kind of replacement feature in forceNumber.\n\n\tYou can now check for yourNumber.void to see if it is set. If .void is true, yourNumber is a Number object which is ready for\n\tmathemetical operation, and defaults to 0, this in contrast with NaN, which is almost totally unusable.\n\n\texample:\n\t```javascript\n\t// generate a void Number:\n\tvar nr= forceNumber();\n\tconsole.log( nr.void );\n\t// true\n\t// don't do the following after a forceNumber without a valid replacement:\n\tconsole.log( nr );\n\t// { void: true }\n\t// instead do what cannot be done with NaN:\n\tconsole.log( 0 + nr );\n\t// 0\n\t// or check before usage:\n\t( nr.void )\n\t\t? console.log( 'void?', nr+= 36/ 4 );\n\t\t: console.log( nr );\n\t// void? 9\n\tetc..\n\t```\n\nUpdated:\n-\tJasmine tests for forceNumber and isDefined\n-\tspeed optimization for isObject\n\n---------------------------------------------------\n1.3.1\n\nAdded:\n- change log in the readme, more convenient overview of changes.\n\n- is/not/has/allDefined<br/>\nNow you can: `if (_.isDefined(value) )`<br/>\ninstead of `if (_.notUndefined(value) )`",
  "readmeFilename": "README.md",
  "gitHead": "35435da58b69e3d93da99716db29586b214d1c65",
  "_id": "types.js@1.3.9",
  "_shasum": "93b972f4e8748d89fbe3cfd01f4045153fca77ce",
  "_from": "types.js@"
}
